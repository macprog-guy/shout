'use strict'

/*

 Benchmarks

 The goal of these small benchmarks is to evaluate the overhead generated by
 the use of our "publish/subscribe" library as opposed to having objects 
 notify observers directly.

 NOTE: we are not measuring the time it takes to PUBLISH the message but 
       NOT the time it takes no receive it, which may depend on other
       factors.

       The main reason why Subcast can achieve higher peformance than
       the simple notification loop is that the latter calls setTimeout 
       with every "change".

       Our publish message calls setTimeout once per timer-event.
       In our case a timer event is about 1ms so all calls to 
       publishAsync are reduced to pushing the message into a queue.
       
*/

const Benchmarkify = require('benchmarkify'),
      benchmark    = new Benchmarkify("Subcast").printHeader(),
      Subcast      = require('../index.js')

const bench = benchmark.createSuite("Asynchronous cases")


const identityWare = (payload, meta, next) => { next(payload, meta) }


// ------------------------------------------------------------------------
//
// Object Notification
//
// NOTE: we use a plain for loop just like in our optimized code because
//       using a for-of loop reduced raw performance.
//
//       Performance here is limited by he call to setTimeout.
//
// ------------------------------------------------------------------------

function notify() {
  
  const o = this.observers,
        n = o.length,
        v = this.value

  setTimeout(() => {
    for (let i=0;  i<n;  i++)
      o[i](this, v)
  }, 0)
}

const object = { value: 1 }
object.observers = [() => {}]
object.notify = notify.bind(object) 


bench.add('Direct observer callback', () => {
  object.notify()
})


// ------------------------------------------------------------------------
//
// Publishing to the root topic with one subscriber
//
// ------------------------------------------------------------------------

const topics1 = Subcast()
topics1.subscribe(() => {})

bench.add('Publish to the root topic with one subscriber', () => {
  topics1.publishAsync('hello')
})


// ------------------------------------------------------------------------
//
// Publishing to a nested topic with one subscriber
//
// ------------------------------------------------------------------------

const topics2   = Subcast(),
      subtopic2 = topics2('foo.bar.baz').subscribe(() => {})

bench.add('Publishing to a nested topic with one subscriber', () => {
  subtopic2.publishAsync('hello')
})


// ------------------------------------------------------------------------
//
// Publishing to a nested topic with subscribers on topic chain
//
// ------------------------------------------------------------------------

const topics3   = Subcast(),
      subtopic3 = topics3('foo')
                    .subscribe(() => {})
                    .subtopic('bar')
                      .subscribe(() => {})
                      .subtopic('baz')
                        .subscribe(() => {})

bench.add('Publishing to a nested topic with subscribers on topic chain', () => {
  subtopic3.publishAsync('hello')
})


// ------------------------------------------------------------------------
//
// Publishing to a nested topic with subscribers all along the topic chain
// and a middleware function at each level also
//
// ------------------------------------------------------------------------

const topics4   = Subcast(),
      subtopic4 = topics4('foo')
                    .use(identityWare)
                    .subscribe(() => {})
                    .subtopic('bar')
                      .use(identityWare)
                      .subscribe(() => {})
                      .subtopic('baz')
                        .use(identityWare)
                        .subscribe(() => {})

bench.add('Publishing to a nested topic with subscribers and middleware on topic chain', () => {
  subtopic4.publishAsync('hello')
})



bench.run()

